#!/usr/bin/env python3
"""
Verify segmentation from results/rests_sequences.json and export:
- results/segmentation_report.json
- results/segmentation_report.md

This script assumes the input is fixed (default): results/rests_sequences.json
Generated by: scripts/01_extract_rests.py
"""

from __future__ import annotations

import argparse
import json
import math
import os
from datetime import datetime
from statistics import mean, median, pstdev
from typing import Any, Dict, List, Tuple, Optional


def load_json(path: str) -> Any:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def ensure_dir(path: str) -> None:
    d = os.path.dirname(os.path.abspath(path))
    if d and not os.path.exists(d):
        os.makedirs(d, exist_ok=True)


def safe_pstdev(xs: List[float]) -> Optional[float]:
    if len(xs) < 2:
        return None
    return pstdev(xs)


def quantiles_simple(xs: List[float]) -> Dict[str, Optional[float]]:
    """
    Simple quantiles without numpy. Uses sorting + linear interpolation.
    Returns q25, q50, q75.
    """
    if not xs:
        return {"q25": None, "q50": None, "q75": None}
    ys = sorted(xs)

    def pick(p: float) -> float:
        if len(ys) == 1:
            return ys[0]
        idx = p * (len(ys) - 1)
        lo = int(math.floor(idx))
        hi = int(math.ceil(idx))
        if lo == hi:
            return ys[lo]
        frac = idx - lo
        return ys[lo] * (1 - frac) + ys[hi] * frac

    return {"q25": pick(0.25), "q50": pick(0.50), "q75": pick(0.75)}


def coalesced_sorted(intervals: List[Tuple[float, float]]) -> bool:
    for i, (s, e) in enumerate(intervals):
        if e < s:
            return False
        if i > 0:
            _ps, pe = intervals[i - 1]
            if s < pe:
                return False
    return True


def intervals_to_lengths(intervals: List[Tuple[float, float]]) -> List[float]:
    return [e - s for s, e in intervals]


def compute_active_gaps(intervals: List[Tuple[float, float]]) -> List[float]:
    """
    Internal "active gaps" between successive rests: rest_end_i -> rest_start_{i+1}.
    """
    gaps: List[float] = []
    for (_s1, e1), (s2, _e2) in zip(intervals, intervals[1:]):
        gaps.append(max(0.0, s2 - e1))
    return gaps


def stats_block(xs: List[float]) -> Dict[str, Any]:
    if not xs:
        return {
            "n": 0,
            "sum": 0.0,
            "min": None,
            "max": None,
            "mean": None,
            "median": None,
            "stdev": None,
            "quantiles": {"q25": None, "q50": None, "q75": None},
        }
    q = quantiles_simple(xs)
    return {
        "n": len(xs),
        "sum": float(sum(xs)),
        "min": float(min(xs)),
        "max": float(max(xs)),
        "mean": float(mean(xs)),
        "median": float(median(xs)),
        "stdev": None if safe_pstdev(xs) is None else float(safe_pstdev(xs)),
        "quantiles": {k: (None if v is None else float(v)) for k, v in q.items()},
    }


def compare_sequences(a: List[float], b: List[float]) -> Dict[str, Any]:
    n = min(len(a), len(b))
    first_mismatch = None
    prefix_match_len = 0
    for i in range(n):
        if abs(a[i] - b[i]) <= 1e-9:
            prefix_match_len += 1
        else:
            first_mismatch = {"index": i, "a": a[i], "b": b[i], "delta": a[i] - b[i]}
            break
    return {
        "len_a": len(a),
        "len_b": len(b),
        "min_len": n,
        "prefix_match_len": prefix_match_len,
        "first_mismatch": first_mismatch,
    }


def fmt_float(x: Optional[float], nd: int = 3) -> str:
    if x is None:
        return "â€”"
    return f"{x:.{nd}f}"


def md_section_dataset(name: str, rests_e8: List[float], rest_intervals_q: List[Tuple[float, float]]) -> str:
    rests_q = [x / 2.0 for x in rests_e8]  # eighth -> quarter
    rest_lengths_q = intervals_to_lengths(rest_intervals_q)
    gaps_q = compute_active_gaps(rest_intervals_q)

    st = stats_block(rests_e8)
    st_int = stats_block(rest_lengths_q)
    st_gap = stats_block(gaps_q)

    q = st["quantiles"]

    lines: List[str] = []
    lines.append(f"## {name}\n\n")
    lines.append(f"- Rests (count): **{len(rests_e8)}**\n")
    lines.append(f"- Total rest: **{sum(rests_e8):.3f}** (eighth) = **{sum(rests_q):.3f}** (quarter)\n\n")

    lines.append("### Rest durations (eighth units)\n")
    lines.append(f"- min / max: {fmt_float(st['min'])} / {fmt_float(st['max'])}\n")
    lines.append(f"- mean / median: {fmt_float(st['mean'])} / {fmt_float(st['median'])}\n")
    lines.append(f"- stdev: {fmt_float(st['stdev'])}\n")
    lines.append(f"- q25 / q50 / q75: {fmt_float(q['q25'])} / {fmt_float(q['q50'])} / {fmt_float(q['q75'])}\n\n")

    lines.append("### Rest intervals (quarter units)\n")
    lines.append(f"- intervals sorted & non-overlapping: **{coalesced_sorted(rest_intervals_q)}**\n")
    lines.append(f"- interval length min / max: {fmt_float(st_int['min'])} / {fmt_float(st_int['max'])}\n\n")

    lines.append("### Active gaps between rests (quarter units)\n")
    lines.append(f"- internal gaps count: **{st_gap['n']}** (should be rests-1)\n")
    lines.append(f"- gap min / max: {fmt_float(st_gap['min'])} / {fmt_float(st_gap['max'])}\n")
    lines.append(f"- gap mean / median: {fmt_float(st_gap['mean'])} / {fmt_float(st_gap['median'])}\n\n")

    lines.append("### First 12 rests (eighth units)\n")
    preview = rests_e8[:12]
    lines.append("`" + ", ".join(str(x) for x in preview) + ("`" if len(rests_e8) <= 12 else ", ...`") + "\n\n")

    return "".join(lines)


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--in", dest="inp", default="results/rests_sequences.json", help="Input rests_sequences.json")
    ap.add_argument("--out-json", default="results/segmentation_report.json", help="Output JSON report path")
    ap.add_argument("--out-md", default="results/segmentation_report.md", help="Output Markdown report path")
    ap.add_argument("--title", default="Segmentation verification report", help="Report title")
    args = ap.parse_args()

    data = load_json(args.inp)

    def get_block(key: str) -> Tuple[List[float], List[Tuple[float, float]]]:
        blk = data.get(key, {})
        rests_e8 = [float(x) for x in blk.get("rests_eighth", [])]
        intervals = blk.get("rest_intervals_quarter", [])
        rest_intervals_q = [(float(s), float(e)) for s, e in intervals]
        return rests_e8, rest_intervals_q

    rests_lumen, intervals_lumen = get_block("lumen")
    rests_nidi, intervals_nidi = get_block("nidi")

    report: Dict[str, Any] = {
        "meta": {
            "title": args.title,
            "generated_at": datetime.now().isoformat(timespec="seconds"),
            "input": os.path.abspath(args.inp),
        },
        "datasets": {},
        "comparisons": {},
    }

    for name, rests_e8, intervals_q in [
        ("lumen", rests_lumen, intervals_lumen),
        ("nidi", rests_nidi, intervals_nidi),
    ]:
        rest_lengths_q = intervals_to_lengths(intervals_q)
        active_gaps_q = compute_active_gaps(intervals_q)
        report["datasets"][name] = {
            "rests_eighth": {"stats": stats_block(rests_e8)},
            "rests_quarter": {"stats": stats_block([x / 2.0 for x in rests_e8])},
            "rest_intervals_quarter": {
                "count": len(intervals_q),
                "sorted_nonoverlapping": coalesced_sorted(intervals_q),
                "length_stats": stats_block(rest_lengths_q),
            },
            "active_gaps_quarter": {
                "count": len(active_gaps_q),
                "stats": stats_block(active_gaps_q),
            },
        }

    report["comparisons"]["rests_eighth_lumen_vs_nidi"] = compare_sequences(rests_lumen, rests_nidi)
    report["comparisons"]["rest_counts"] = {
        "lumen": len(rests_lumen),
        "nidi": len(rests_nidi),
        "delta": len(rests_lumen) - len(rests_nidi),
    }
    report["comparisons"]["total_rest_eighth"] = {
        "lumen": float(sum(rests_lumen)),
        "nidi": float(sum(rests_nidi)),
        "delta": float(sum(rests_lumen) - sum(rests_nidi)),
    }

    ensure_dir(args.out_json)
    with open(args.out_json, "w", encoding="utf-8") as f:
        json.dump(report, f, indent=2, ensure_ascii=False)

    md: List[str] = []
    md.append(f"# {args.title}\n\n")
    md.append(f"- Generated at: `{report['meta']['generated_at']}`\n")
    md.append(f"- Input: `{report['meta']['input']}`\n\n")

    md.append("## Summary\n\n")
    md.append(f"- Lumen rests: **{len(rests_lumen)}** (total **{sum(rests_lumen):.3f}** eighth)\n")
    md.append(f"- Nidi rests: **{len(rests_nidi)}** (total **{sum(rests_nidi):.3f}** eighth)\n")
    cmp_seq = report["comparisons"]["rests_eighth_lumen_vs_nidi"]
    md.append(f"- Prefix match (eighth list): **{cmp_seq['prefix_match_len']}** / {cmp_seq['min_len']}\n")
    if cmp_seq["first_mismatch"] is not None:
        fm = cmp_seq["first_mismatch"]
        md.append(f"- First mismatch at index {fm['index']}: Lumen={fm['a']} vs Nidi={fm['b']} (delta={fm['delta']})\n")
    md.append("\n")

    md.append(md_section_dataset("Lumen", rests_lumen, intervals_lumen))
    md.append(md_section_dataset("Nidi (Panel 1)", rests_nidi, intervals_nidi))

    md.append("## Comparison (Lumen vs Nidi)\n\n")
    md.append(f"- Rest count delta: **{len(rests_lumen) - len(rests_nidi)}**\n")
    md.append(f"- Total rest (eighth) delta: **{sum(rests_lumen) - sum(rests_nidi):.3f}**\n")
    md.append(f"- First mismatch: {cmp_seq['first_mismatch']}\n")

    ensure_dir(args.out_md)
    with open(args.out_md, "w", encoding="utf-8") as f:
        f.write("".join(md))

    print("[OK] Wrote JSON report ->", args.out_json)
    print("[OK] Wrote MD report   ->", args.out_md)
    print("[INFO] Lumen rests:", len(rests_lumen), "Total(eighth):", f"{sum(rests_lumen):.3f}")
    print("[INFO] Nidi  rests:", len(rests_nidi), "Total(eighth):", f"{sum(rests_nidi):.3f}")


if __name__ == "__main__":
    main()

